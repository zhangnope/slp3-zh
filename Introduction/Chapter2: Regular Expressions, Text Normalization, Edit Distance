Chapter 2:
  
  User: I am unhappy.
  ELIZA: DO YOU THINK COMING HERE WILL HELP YOU NOT TO BE UNHAPPY
  User: I need some help, that much seems certain.
  ELIZA: WHAT WOULD IT MEAN TO YOU IF YOU GOT SOME HELP
  User: Perhaps I could learn to get along with my mother.
  ELIZA: TELL ME MORE ABOUT YOUR FAMILY
  User: My mother takes care of me.
  ELIZA: WHO ELSE IN YOU FAMILY TAKES CARE OF YOU
  User: My father.
  ELIZA: YOUR FATHER
  User: You are like my father in some ways.

上述对话来自于 ELIZA ，一个早期的自然语言处理系统，它可以通过模仿罗杰斯学派的心理治疗师的反应来与用户进行有限的对话。 ELIZA 是一个令人惊讶的简单程序，
它使用模式匹配来识别短语，例如："I need X"短语，并将其翻译成合适的语句，例如"What would it mean to you if you got X?"。这个简单的机器在这一领域取
得了巨大的成功，因为 ELIZA 在模仿罗杰斯学派的心理治疗师时不需要真正的 领会 任何事情。正如 Weizenbaum 指出的，它是少数几种可以表现得自身对真实世界一
无所知的对话系统之一。 ELIZA 人类对话非常成功：很多与其交互的人们开始相信 ELIZA 真正的 理解 他们和他们的问题，甚至在程序的工作原理被解释给他们之后，
很多人们依旧相信 ELIZA 的理解能力。即使在今天这样的聊天机器人也是种有趣的娱乐方式。

当然，现代对话系统不仅是一种娱乐手段：他们可以回答问题，预定航班或者寻找餐厅。他们的这些功能依赖于自身对于用户意图更复杂的理解，我们将在 Chapter26中做
更多解释。尽管如此， ELIZA 和其他聊天机器人依赖的简单的基于模式(识别)的方法在自然语言处理中仍起着至关重要的作用。

我们将从描述文本模式的最重要工具开始：正则表达式[regular expression]。自上述的 ELIZA 中"I need X"转换而来，正则表达式可以用作从文档中提取指定的字符串，
以定义字符串（如 $199 或 $24.99）从文档中提取价格表。

然后，我们将集体讨论一组称为文本规范化[text normalization]的任务，正则表达式在其中扮演了重要的作用。规范化文本是指将其转换为更方便、更标准的形式。例如，
大多数我们对于语言的处理首先依赖于从流动的文本中分离出或标记单词————标记化任务。 英语单词间的区分通常以空白格作为标准，但是空白格不总是有效地。 New York
和 rock 'n' roll 有时被认为是大一些的单词，尽管他们中含有空格；与此同时，我们有时需要把 I'm 分解成两个单词 I 和 am。为了处理推特或短信，我们需要标记表
情符号，如 :) ，或者话题标签，如 #nlproc。有些语言，如日语，单词之间没有空白格，因此对于它们的标记化变得更难。

文本规范化的另一部分称为词形还原[lemmatization]————判断两个词是否有相同的词根的任务，尽管这两个词会有明显的差异。例如，单词sang, sung, sings都是动词
sing的形式。单词sing是这些单词的通用词形，一个词形还原器将全部这些单词归为sing。词形还原对于处理像阿拉伯语这样形态复杂的语言是至关重要的。词干提取[Stemming]
是词形还原的一种简化版本，主要是将后缀从单词的末尾剥离。文本规范化还包括句子切分[sentence segmentation]：使用如句号或感叹号，将文本分割成单独的句子。

最后，我们需要比较单词和其他字符串。我们将引入一套度量标准————编辑距离[edit distance]————通过一个字符串经过(插入、删除、替换)变成另一个字符串的编辑
次数来衡量两个字符串的相似程度。编辑距离是一种应用于整个语言处理的算法————从拼写纠正到语音识别，再到核心推理的解决。


2.1 正则表达式[regular expression]
在计算机科学的标准化方面，一个默默无闻的成功案例是正则表达式[regular expression(RE)]———— 一种用于文本搜索指定字符串的语言。这种实用的语言被用于每一
种计算机语言、文字处理器和文本处理工具，如Unix工具grep或Emacs。形式上，正则表达式是用于描述一组字符串的代数符号。当我们有一个搜索模式和一个要搜索的文本
语料库时，它们对于文本中的搜索特别有用。正则表达式搜索功能将搜索整个语料库，返回所有符合该模式的文本。语料库可以是一个单一的文档或一个它们的集合。例如，
Unix命令行工具grep使用正则表达式，然后返回输入文档中满足表达式的每一行。

搜索可以被设计成返回一行中的每个匹配，如果有超过一个匹配的话，或者只返回第一个匹配。在下面的例子中，我们一般会在模式中与正则表达式相匹配的确切部分下划线，
并只显示第一个匹配。我们将展示以斜线为界的正则表达式，但注意斜线 不 是正则表达式的一部分。

正则表达式有多种变体。我们将对扩展的正则表达式进行描述；不同的正则表达式分析器可能只识别他们的子集，或者对某些表达式的处理方式略有不同。使用在线的正则表达式
测试器是测试你的表达式和探索这些变化的一个简便方式。


2.1.1 基本的正则表达式模式[Basic Regular Expression Patterns]
简单的正则表达方式是一系列简单的字符。为了搜索 woodchuck，我们输入 /woodchuck/。表达式 /Buttercup/ 匹配所有含有子串 Buttercup 的字符串；此表达式在
grep中会返回 I’m called little Buttercup 这行。用于搜索的字符串可以包含单一字符，如 /!/ ，或者一个字符序列，如 /urgl/。

正则表达式是大小写敏感的，小写 /s/ 不同于大写 /S/ (/s/匹配小写的s而不是大写的S)。这意味着模式 /woodchucks/ 不会匹配字符串 Woodchucks。我们可以通过使用
方形大括号 [and] 来解决这一问题。

